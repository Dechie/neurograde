{
  "p02256": {
    "title": "Greatest Common Divisor",
    "statement": "## Greatest Common Divisor\nWrite a program which finds the greatest common divisor of two natural numbers a and b.\n\n## Hint\nYou can use the following observation:\n\nFor integers x and y, if x >= y, then gcd(x, y) = gcd(y, x%y)",
    "input_spec": "a and b are given in a line sparated by a single space.\n\n## Constraints\n1 <= a, b <= 10^9\n\n## Sample Input 1\n```\n54 20\n```\n\n## Sample Input 2\n```\n147 105\n```",
    "output_spec": "Output the greatest common divisor of a and b.\n\n## Sample Output 1\n```\n2\n```\n\n## Sample Output 2\n```\n21\n```",
    "accepted": "\n\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Main{\n  public static void main(String args[]) throws IOException{\n   BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n   String[] string =  br.readLine().split(\" \");\n\n   int x = Integer.parseInt( string[0] );\n   int y = Integer.parseInt( string[1] );\n\n   int tmp;\n\n   if(x < y){\n\n\t   tmp = x;\n\t   x = y;\n\t   y = tmp;\n\n   }\n\n   int r = x % y;\n   while(r!=0){\n     x = y;\n     y = r;\n\t r = x % y;\n   }\n\n   System.out.println(y);\n\n }\n}"
  },
  "p03200": {
    "title": "Problem Statement\n\nThere are N Reversi pieces arranged in a row. (A Reversi piece is a disc with a black side and a white side.)\nThe state of each piece is represented by a string S of length N.\nIf S_i=B, the i-th piece from the left is showing black;\nIf S_i=W, the i-th piece from the left is showing white.\nConsider performing the following operation:\n\nChoose i (1 <= i < N) such that the i-th piece from the left is showing black and the (i+1)-th piece from the left is showing white, then flip both of those pieces. That is, the i-th piece from the left is now showing white and the (i+1)-th piece from the left is now showing black.\n\nFind the maximum possible number of times this operation can be performed.",
    "statement": "## Problem Statement\n\nThere are N Reversi pieces arranged in a row. (A Reversi piece is a disc with a black side and a white side.)\nThe state of each piece is represented by a string S of length N.\nIf S_i=B, the i-th piece from the left is showing black;\nIf S_i=W, the i-th piece from the left is showing white.\nConsider performing the following operation:\n\nChoose i (1 <= i < N) such that the i-th piece from the left is showing black and the (i+1)-th piece from the left is showing white, then flip both of those pieces. That is, the i-th piece from the left is now showing white and the (i+1)-th piece from the left is now showing black.\n\nFind the maximum possible number of times this operation can be performed.",
    "input_spec": "Input is given from Standard Input in the following format:\nS\n\nConstraints\n1 <= |S| <= 2 * 10^5\nS_i=B or W\n\nSample Input 1\n```\nBBW\n```\n\nSample Input 2\n```\nBWBWBW\n```",
    "output_spec": "Print the maximum possible number of times the operation can be performed.\n\nSample Output 1\n```\n2\n```\nThe operation can be performed twice, as follows:\n\nFlip the second and third pieces from the left.\nFlip the first and second pieces from the left.\n\n\nSample Output 2\n```\n6\n```",
    "accepted": "s=input()\n\nans=0\nb_cnt=0\nfor i in range(len(s)):\n  if s[i]=='B':\n    b_cnt+=1\n  else:\n    ans+=b_cnt\n\nprint(ans)",
    "wrong_answer": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint main(){\n  string s;\n  cin >> s;\n  int c=0, Ws=0;\n  for(int i=0; i<s.length(); i++){\n    if(s[i] == 'W'){\n      c+=i-Ws;\n      Ws++;\n    } \n  }\n    cout << c;\nreturn 0;\n}"
  },
  "p02734": {
    "title": "Given are a sequence of N integers A_1, A_2, ..., A_N and a positive integer S.\nFor a pair of integers (L, R) such that 1<= L <= R <= N, let us define f(L, R) as follows:\n\nf(L, R) is the number of sequences of integers (x_1, x_2, ..., x_k) such that L <= x_1 < x_2 < ... < x_k <= R and A_{x_1}+A_{x_2}+...+A_{x_k} = S.\n\nFind the sum of f(L, R) over all pairs of integers (L, R) such that 1<= L <= R<= N. Since this sum can be enormous, print it modulo 998244353.",
    "statement": "Given are a sequence of N integers A_1, A_2, ..., A_N and a positive integer S.\nFor a pair of integers (L, R) such that 1<= L <= R <= N, let us define f(L, R) as follows:\n\nf(L, R) is the number of sequences of integers (x_1, x_2, ..., x_k) such that L <= x_1 < x_2 < ... < x_k <= R and A_{x_1}+A_{x_2}+...+A_{x_k} = S.\n\nFind the sum of f(L, R) over all pairs of integers (L, R) such that 1<= L <= R<= N. Since this sum can be enormous, print it modulo 998244353.",
    "input_spec": "Input is given from Standard Input in the following format:\nN S\nA_1 A_2 ... A_N\n\nConstraints\nAll values in input are integers.\n1 <= N <= 3000\n1 <= S <= 3000\n1 <= A_i <= 3000\n\nSample Input 1\n```\n3 4\n2 2 4\n```\n\nSample Input 2\n```\n5 8\n9 9 9 9 9\n```\n\nSample Input 3\n```\n10 10\n3 1 4 1 5 9 2 6 5 3\n```",
    "output_spec": "Print the sum of f(L, R), modulo 998244353.\n\nSample Output 1\n```\n5\n```\nThe value of f(L, R) for each pair is as follows, for a total of 5.\n\nf(1,1) = 0\nf(1,2) = 1 (for the sequence (1, 2))\nf(1,3) = 2 (for (1, 2) and (3))\nf(2,2) = 0\nf(2,3) = 1 (for (3))\nf(3,3) = 1 (for (3))\n\n\nSample Output 2\n```\n0\n```\n\nSample Output 3\n```\n152\n```",
    "wrong_answer": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static int N, S;\n    static int[] A;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt();\n        S = sc.nextInt();\n        A = sc.nextIntArray(N);\n\n        System.out.println(solve());\n    }\n\n    static int solve() {\n        // 開始位置覚えてないとダメじゃんってなって終了したけど最初からかけておけばよいのね…\n        int[] curr = new int[S+1];\n        int ret = 0;\n        for (int i = 0; i < N; i++) {\n            int a = A[i];\n            int[] next = new int[S+1];\n            // 開始を決める\n            // 横に(i+1)個数あるので掛けておけば開始位置を覚えておかないで済む(これが出なかった...)\n            if( a <= S ) {\n                next[a] += i+1;\n            }\n\n            // 足したり足さなかったり\n            for (int s = 0; s < S; s++) {\n                if( s + a <= S ) {\n                    next[s+a] += curr[s];\n                    next[s+a] %= MOD;\n                }\n                next[s] += curr[s];\n                next[s] %= MOD;\n            }\n\n            // ここで終了した分\n            int end = next[S] * (N-i) % MOD;\n            ret += end;\n            ret %= MOD;\n            curr = next;\n        }\n        return ret;\n    }\n\n    static int MOD = 998244353;\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeSingleLine(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(as[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg == null) j.add(\"null\");\n            else if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n\n    static void printSingleLine(int[] array) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int i = 0; i < array.length; i++) {\n            if (i != 0) pw.print(\" \");\n            pw.print(array[i]);\n        }\n        pw.println();\n        pw.flush();\n    }\n\n    static int lowerBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] < value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n\n    static int upperBound(int[] array, int value) {\n        int lo = 0, hi = array.length, mid;\n        while (lo < hi) {\n            mid = (hi + lo) / 2;\n            if (array[mid] <= value) lo = mid + 1;\n            else hi = mid;\n        }\n        return lo;\n    }\n}\n",
    "accepted": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define repl(i,l,r) for(ll i=(l);i<(r);i++)\n#define per(i,n) for(ll i=n-1;i>=0;i--)\n#define perl(i,r,l) for(ll i=r-1;i>=l;i--)\n#define fi first\n#define se second\n#define pb push_back\n#define ins insert\n#define pqueue(x) priority_queue<x,vector<x>,greater<x>>\n#define all(x) (x).begin(),(x).end()\n#define CST(x) cout<<fixed<<setprecision(x)\n#define vtpl(x,y,z) vector<tuple<x,y,z>>\n#define rev(x) reverse(x);\nusing ll=long long;\nusing vl=vector<ll>;\nusing vvl=vector<vector<ll>>;\nusing pl=pair<ll,ll>;\nusing vpl=vector<pl>;\nusing vvpl=vector<vpl>;\nconst ll MOD=1000000007;\nconst ll MOD9=998244353;\nconst int inf=1e9+10;\nconst ll INF=4e18;\nconst ll dy[8]={1,0,-1,0,1,1,-1,-1};\nconst ll dx[8]={0,-1,0,1,1,-1,1,-1};\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nint main(){\n    ll n,s;cin >> n >>s;\n    vvl dp(n+1,vl(s+1,0));\n    vl a(n);rep(i,n)cin >> a[i];\n    //a[0]=inf;\n    dp[0][0]=0;\n    rep(i,n){\n        rep(j,s+1){\n            if(j+a[i]<=s){\n                dp[i+1][j+a[i]]+=dp[i][j];\n                dp[i+1][j+a[i]]%=MOD9;\n            }\n            dp[i+1][j]+=dp[i][j];\n            dp[i+1][j]%=MOD9;\n        }\n        dp[i+1][0]++;\n        if(a[i]<=s)dp[i+1][a[i]]++;\n    }\n    ll ans=0;\n    rep(i,n+1){\n        ans+=dp[i][s];\n        ans%=MOD9;\n    }\n    cout <<ans <<endl;\n}   "
  },
 "p03949": {
    "title": "Tree Integer Assignment with Difference Condition",
    "input_spec": "The input describes a tree and some pre-assigned integer values for certain vertices.\n* **N**: An integer, the number of vertices in the tree (1 <= N <= 10^5).\n* **A_i, B_i**: N-1 pairs of integers representing the edges of the tree, where an edge connects vertex A_i and vertex B_i (1 <= A_i, B_i <= N).\n* **K**: An integer, the number of vertices with pre-assigned values (1 <= K <= N).\n* **V_j, P_j**: K pairs of integers, where P_j is the integer written into vertex V_j (1 <= V_j <= N, 0 <= P_j <= 10^5). All V_j are distinct.",
    "output_spec": "If it's **possible** to assign integers to all empty vertices satisfying the condition, print \"Yes\".\nFollowing \"Yes\", print N lines. The v-th line should contain the integer assigned to vertex v. Any valid assignment is accepted.\nIf it's **not possible**, print \"No\"."
  },
  "p03003":{
    "title": "Common Subsequences Count",
    "input_spec": "Input consists of two integer sequences.\n* **N, M**: Two integers representing the lengths of sequences S and T, respectively (1 <= N, M <= 2 * 10^3).\n* **S_sequence**: N integers representing the sequence S (1 <= S_i <= 10^5).\n* **T_sequence**: M integers representing the sequence T (1 <= T_i <= 10^5).",
    "output_spec": "Print a single integer: the number of pairs of subsequences (one from S, one from T) that are identical in content, modulo 10^9+7."
  },
  "p03863": {
    "title": "String Game with Character Removal",
    "input_spec": "Input is a single string.\n* **s**: A string of lowercase English letters (3 <= |s| <= 10^5). No two neighboring characters in s are equal.",
    "output_spec": "Print \"First\" if Takahashi (the first player) wins.\nPrint \"Second\" if Aoki (the second player) wins."
  },
  "p03732":{
    "title": "Knapsack Problem with Limited Weight Differences",
    "input_spec": "Input describes a set of items and a bag capacity.\n* **N, W**: Two integers, the number of items and the maximum weight capacity of the bag, respectively (1 <= N <= 10^0, 1 <= W <= 10^9).\n* **w_i, v_i**: N pairs of integers, representing the weight and value of the i-th item (1 <= w_i <= 10^9, 1 <= v_i <= 10^7).\n* A special constraint: for each i = 2, 3, ..., N, it's guaranteed that w_1 <= w_i <= w_1 + 3.",
    "output_spec": "Print a single integer: the maximum possible total value of the selected items that can be put into the bag without exceeding its weight capacity."
  }
}